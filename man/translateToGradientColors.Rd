% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/protein3d.R
\name{translateToGradientColors}
\alias{translateToGradientColors}
\title{translateToGradientColors}
\usage{
translateToGradientColors(
  minValue,
  maxValue,
  colorSteps = 1000,
  colors,
  transformFunction = NA
)
}
\arguments{
\item{minValue}{minimum value to use when translating to colors. If a value is lower than this,
it will be set to this}

\item{maxValue}{maximum value to use when translating to colors. If a value is higher than thism
it will be set to this}

\item{colorSteps}{essentially the resolution of the gradient. If set to 1000 (default), then
a gradient of 1000 individual colors will be created to translate to. Do not set excessively high
or low}

\item{colors}{two element character vector. Specifies the colors for the minimumValue amd the
maximumValue. The translation will have 'colorSteps' gradations between these two colors}

\item{transformFunction}{allows for passing a transformation function to the values to be
translated. The minValue and maxValue arguments will also be transformed. This can be used where
the value-range is (very) large}
}
\value{
function that takes the argument 'value', which is then used to translate the argument to
the corresponding color(code)s. The function is vectorized so the argument can be multi-element.
Note: the 'transformFunction' specified is applied to the argument!
}
\description{
function factory that generates a function that 'tramslates' (maps) protein data
to colors. Meant for continous data. If the colors are then used as a columnn for the
protein data data.frame, it can be used modify colors on a 3d protein object. See
\code{\link{addStyleElement}} for more info'
}
\examples{
# create protein data
ovaProtein <- proteinCoverage(sequence = standardProtein(),
 peptideTable = OVATable("peptide"), Accession = "P01012",
 positionColumn = "PositionsinProteins", shiftPosition = 1)
# mapping Abundance information
ovaProtein <- mapPeptidesToProtein(proteinDF = ovaProtein, peptideTable = OVATable("peptide"),
 Accession = "P01012", positionColumn = "PositionsinProteins",
 shiftPosition = 1L, variable = "Abundances_1",
 dataName = "Abundance", combineFunction = sum)
# create the color translation function
linearColors <- translateToGradientColors(minValue = min(ovaProtein$Abundance),
 maxValue = max(ovaProtein$Abundance),
 colorSteps = 1000, colors = c("white", "blue"))
linearColors(c(0, 1E5, 1E9))
# create a logarithmic translation function
logColors <- translateToGradientColors(minValue = 1E3,
 maxValue = 1E10,
 colorSteps = 1000, colors = c("white", "blue"), transformFunction = log10p)
logColors(c(0, 1E5, 1E9))
# this doesn't work, due to log10 not generating NA's
logColors <- translateToGradientColors(minValue = min(ovaProtein$Abundance),
 maxValue = max(ovaProtein$Abundance),
 colorSteps = 1000, colors = c("white", "blue"), transformFunction = log10)
logColors(c(0, 1E5, 1E9))
# this does work
logColors <- translateToGradientColors(minValue = min(ovaProtein$Abundance),
 maxValue = max(ovaProtein$Abundance),
 colorSteps = 1000, colors = c("white", "blue"), transformFunction = log10p)
logColors(c(0, 1E5, 1E9))
# limit the value range
logColors <- translateToGradientColors(minValue = 1E3,
 maxValue = max(ovaProtein$Abundance),
 colorSteps = 1000, colors = c("white", "blue"), transformFunction = log10)
logColors(c(0, 1E5, 1E9))
# same result in a different way
logColors <- translateToGradientColors(minValue = min(ovaProtein$Abundance),
 maxValue = max(ovaProtein$Abundance),
 colorSteps = 1000, colors = c("white", "blue"), transformFunction = log10add(1E3))
logColors(c(0, 1E5, 1E9))
# add the colors to the protein data
ovaProtein$AbundanceColors <- linearColors(ovaProtein$Abundance)
ovaProtein$AbundanceLogColors <- logColors(ovaProtein$Abundance)
ovaProtein |> dplyr::slice(35:45)
ovaProtein |> dplyr::slice(360:375)
}
